#!/bin/sh
# Copyright (c) 2022, Prasad Tengse
# shellcheck disable=SC2034,SC2155,SC2039

# Script Constants
CURDIR="$(cd -P -- "$(dirname -- "")" && pwd -P)"
SCRIPT="$(basename "$0")"

# HOOKS DIRs
if [ "$CI_TEST_MODE" = "703004ad-3b6c-4baa-84c5-868dd09acd06" ]; then
    BOOT_HOOKS_DIR="/tmp/703004ad-3b6c-4baa-84c5-868dd09acd06.boot-hooks.d"
else
    BOOT_HOOKS_DIR="/mnt/data/udm-boot-hooks.d"
fi

# Handle Signals
# trap ctrl-c and TERM
trap ctrl_c_signal_handler INT
trap term_signal_handler TERM

ctrl_c_signal_handler() {
    log_error "User Interrupt! CTRL-C"
    exit 4
}

term_signal_handler() {
    log_error "Signal Interrupt! SIGTERM"
    exit 4
}

#diana::snippet:shlib-logger:begin#
# shellcheck shell=sh
# shellcheck disable=SC3043

# SHELL LOGGING LIBRARY
# See https://github.com/tprasadtp/shlibs/logger/README.md
# If included in other files, contents between snippet markers
# might automatically be updated (depending on who manages it)
# and all changes between markers might be ignored.

# Logger core ::internal::
# This function should NOT be called directly.
__logger_core_event_handler() {
    [ "$#" -lt 2 ] && return 1

    local lvl_caller="${1:-info}"

    # Logging levels are similar to python's logging levels
    case ${lvl_caller} in
    trace)
        level="0"
        ;;
    debug)
        level="10"
        ;;
    info)
        level="20"
        ;;
    success)
        level="20"
        ;;
    notice)
        level="25"
        ;;
    warning)
        level="30"
        ;;
    error)
        level="40"
        ;;
    critical)
        level="50"
        ;;
    *)
        level="100"
        ;;
    esac

    # Immediately return if log level is not enabled
    # If LOG_LVL is not set, defaults to 20 - info level
    [ "${LOG_LVL:-20}" -gt "${level}" ] && return

    shift
    local lvl_msg="$*"

    # Detect whether to coloring is disabled based on env variables,
    # and if output Terminal is intractive.
    # This supports following standards.
    #  - https://bixense.com/clicolors/
    #  - https://no-color.org/

    local lvl_color
    local lvl_colorized
    local lvl_color_reset

    # Forces colored logs
    # - if CLICOLOR_FORCE is set and is not zero
    if [ -n "${CLICOLOR_FORCE}" ] && [ "${CLICOLOR_FORCE}" != "0" ]; then
        lvl_colorized="true"
        # shellcheck disable=SC2155
        lvl_color_reset="\e[0m"

    # Disable colors if one of the conditions are true
    # - CLICOLOR = 0
    # - NO_COLOR is set to non empty value
    # - TERM is set to dumb
    elif [ -n "${NO_COLOR}" ] || [ "${CLICOLOR}" = "0" ] || [ "${TERM}" = "dumb" ]; then
        lvl_colorized="false"

    # Enable colors if not already disabled or forced and terminal is interactive
    elif [ -t 1 ] && [ -t 2 ]; then
        lvl_colorized="true"
        # shellcheck disable=SC2155
        lvl_color_reset="\e[0m"
    fi

    # Level name in string format
    local lvl_prefix
    # Level name in string format with timestamp if enabled or level symbol
    local lvl_string

    # Log format
    if [ "${LOG_FMT:-pretty}" = "pretty" ] && [ "${lvl_colorized}" = "true" ]; then
        lvl_string="â€¢"
    elif [ "${LOG_FMT}" = "full" ] || [ "${LOG_FMT}" = "long" ]; then
        # shellcheck disable=SC2155
        lvl_prefix="$(date --rfc-3339=s) "
    fi

    # Define level, color and timestamp
    # By default we do not show log level and timestamp.
    # However, if LOG_FMT is set to "full" or "long",
    # we will enable long format with timestamps
    case "$lvl_caller" in
    trace)
        # if lvl_string is set earlier, that means LOG_FMT is default or pretty
        # we dont display timestamp or level name in this case. otherwise
        # append level name to lvl_prefix
        # (lvl_prefix is populated with timestamp if LOG_FMT is full or long)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[TRACE   ]"
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;246m"
        ;;
    debug)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[DEBUG   ]"
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;250m"
        ;;
    info)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[INFO    ]"
        # Avoid printing color reset sequence as this level is not colored
        [ "${lvl_colorized}" = "true" ] && lvl_color_reset=""
        ;;
    success)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[INFO    ]"
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;83m"
        ;;
    notice)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[NOTICE  ]"
        # shellcheck disable=SC2155
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;81m"
        ;;
    warning)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[WARNING ]"
        # shellcheck disable=SC2155
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;214m"
        ;;
    error)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[ERROR   ]"
        # shellcheck disable=SC2155
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;197m"
        ;;
    critical)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[CRITICAL]"
        # shellcheck disable=SC2155
        [ "${lvl_colorized}" = "true" ] && lvl_color="\e[38;5;196m"
        ;;
    *)
        [ -z "${lvl_string}" ] && lvl_string="${lvl_prefix}[UNKNOWN ]"
        # Avoid printing color reset sequence as this level is not colored
        [ "${lvl_colorized}" = "true" ] && lvl_color_reset=""
        ;;
    esac

    # By default logs are written to stderr
    case "${LOG_TO_STDOUT:-false}" in
    true | True | TRUE | Yes | yes | YES | 1)
        printf "${lvl_color}%s %s ${lvl_color_reset}\n" "${lvl_string}" "$lvl_msg"
        ;;
    *)
        printf "${lvl_color}%s %s ${lvl_color_reset}\n" "${lvl_string}" "$lvl_msg" 1>&2
        ;;
    esac
}

# Leveled Loggers
log_trace() {
    __logger_core_event_handler "trace" "$@"
}

log_debug() {
    __logger_core_event_handler "debug" "$@"
}

log_info() {
    __logger_core_event_handler "info" "$@"
}

log_success() {
    __logger_core_event_handler "success" "$@"
}

log_warning() {
    __logger_core_event_handler "warning" "$@"
}

log_warn() {
    __logger_core_event_handler "warning" "$@"
}

log_notice() {
    __logger_core_event_handler "notice" "$@"
}

log_error() {
    __logger_core_event_handler "error" "$@"
}

log_critical() {
    __logger_core_event_handler "critical" "$@"
}

# For logging command outputs
# Pipe output of your command to this function
# This is EXPERIMENTAL FEATURE!!
# If used without a pipe causes script to hang!
# - Accepts one optioanl argument.
#  ARG 1 (str) - msg prefix, this will be prefixed with every line of output
log_tail() {
    local line prefix
    [ -n "$1" ] && prefix="($1) "
    while read -r line; do
        __logger_core_event_handler "trace" "$prefix$line"
    done
}
#diana::snippet:shlib-logger:end#

display_usage() {
    cat <<EOF
UDM Hooks Manager

Usage: hookctl [OPTIONS] ACTION [HOOK]

Commands:
    ls [state]            List all the hooks
    rm [HOOK]             Remove hook
    install [FILE]        Install hook
    disable [HOOK]        Disable hook
    enable  [HOOK]        Enable hook
    invoke-start [HOOK]   Invoke start on single hook
    invoke-stop  [HOOK]   Invoke stop  on single hook
    invoke-all start      Invoke start on all hooks
    invoke-all stop       Invoke stop  on all hooks
    help                  display this help message

Global Options:
  -h, --help              Display this help message

Examples:
  ${SCRIPT} help
  ${SCRIPT} ls installed
  ${SCRIPT} ls enabled
  ${SCRIPT} ls disabled
  ${SCRIPT} ls all

  ${SCRIPT} install /tmp/my-hook
  ${SCRIPT} enable my-hook
  ${SCRIPT} disable ${BOOT_HOOKS_DIR}/my-hook

  ${SCRIPT} invoke start my-hook
  ${SCRIPT} invoke stop ${BOOT_HOOKS_DIR}/my-hook

  ${SCRIPT} invoke-all start
  ${SCRIPT} invoke-all stop

Environment:
  LOG_TO_STDOUT       Set this to 'true' to log to stdout.
  NO_COLOR            Set this to NON-EMPTY to disable all colors.
  CLICOLOR_FORCE      Set this to NON-ZERO to force colored output.
EOF
}

# Checks if command is available
__has_command() {
    if command -v "$1" >/dev/null; then
        return 0
    else
        return 1
    fi
    return 1
}

hookctl_enforce_ubios() {
    if ! grep -q "UbiOS" /etc/os-release; then
        if [ "$CI_TEST_MODE" = "703004ad-3b6c-4baa-84c5-868dd09acd06" ]; then
            log_warn "Not enforcing OS requirements due to CI_TEST_MODE"
        else
            log_error "hookctl MUST be executed from UbiOS, not Podman container!"
            exit 1
        fi
    fi
}

# checks if given input is integer
is_integer() {
    case "$1" in
    "" | *[!0-9]*)
        return 1
        ;;
    *)
        return 0
        ;;
    esac
}

# Checks if given input is invocaation id
is_invocation_id() {
    if printf "%s" "$1" | grep -qE '^[A-Za-f0-9]{16}$'; then
        return 0
    else
        return 1
    fi
}

__hooks_dir_present() {
    if [ -d "$BOOT_HOOKS_DIR" ]; then
        return 0
    else
        return 1
    fi
}

# Checks if given hook type is present (may not be enabled)
__is_hook_present() {
    local hook="$1"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        return 1
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    if [ -f "$hook" ]; then
        return 0
    else
        return 1
    fi
}

__is_hook_enabled() {
    local hook="$1"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        return 1
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    log_debug "Checking if enabled - $hook"
    if [ -x "$hook" ] && [ -f "$hook" ]; then
        return 0
    else
        return 255
    fi

}

# Invokes a single hook
__invoke_hook_core() {
    local hook="$1"
    local invoke_mode="${2:-NA}"
    local invoke_timeout="${3:-120}"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        return 255
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    case "$invoke_mode" in
    start | stop)
        :
        ;;
    *)
        log_critical "__invoke_hook_core called with invalid invoke_mode - ${invoke_mode}"
        return 255
        ;;
    esac

    if is_integer "$invoke_timeout"; then
        if [ "$invoke_timeout" -lt 10 ] || [ "$invoke_timeout" -gt 600 ]; then
            log_critical "__invoke_start called with invalid hook out of bonds timeout (min=10,max=600) - ${invoke_timeout}"
            return 255
        fi
    else
        log_critical "__invoke_start called with invalid hook timeout - ${invoke_timeout}"
        return 255
    fi

    if timeout "$invoke_timeout" "$hook" "$invoke_mode"; then
        log_success "Invoke hook=$hook mode=$invoke_mode executed successfully"
        return 0
    else
        log_error "Invoke hook=$hook mode=$invoke_mode returned non zero exit code"
        return 255
    fi

}

__invoke_hook_all() {
    local invoke_mode="$1"
    local invoke_timeout="${3:-300}"

    case "$invoke_mode" in
    start | stop)
        :
        ;;
    *)
        log_critical "Unsupported invoke_mode - ${invoke_mode:-NA}"
        exit 2
        ;;
    esac

    if __hooks_dir_present; then
        # collect all hooks
        log_info "Collecting hooks"
        local hooks_list
        hooks_list="$(find "${BOOT_HOOKS_DIR}" -maxdepth 1 -type f | sort -V)"
        if [ -z "$hooks_list" ]; then
            log_warn "No hooks to execute!"
            return 0
        else
            echo "$hooks_list" | while read -r line; do
                if __is_hook_enabled "$line"; then
                    if __invoke_hook_core "$line" "$invoke_mode" "$invoke_timeout"; then
                        log_success "Success hook=$line mode=$invoke_mode"
                    else
                        log_error "Failed! hook=$line mode=$invoke_mode "
                        break
                    fi
                else
                    log_info "Not enabled hook=$line type=$hook_type"
                fi
            done

        fi
    else
        # This is not an error, user might not have any hooks!
        log_warn "Hooks directory - $BOOT_HOOKS_DIR not present!"
        exit 0
    fi
}

# Invoke a single hook
__invoke_hook_single() {
    local hook="$2"
    local invoke_mode="$1"
    local invoke_timeout="${3:-300}"

    case "$invoke_mode" in
    start | stop)
        :
        ;;
    *)
        log_critical "__invoke_hook_single called with invalid invoke_mode - ${invoke_mode:-NA}"
        exit 2
        ;;
    esac

    if __is_hook_present "$hook"; then
        if __is_hook_enabled "$hook"; then
            if __invoke_hook_core "$hook" "$invoke_mode" "${invoke_timeout}"; then
                log_success "Success! hook=$hook"
            else
                log_error "Failed! hook=$hook"
                exit 1
            fi
        else
            log_error "Hook not enabled hook=$hook"
            exit 1
        fi
    else
        # This is not an error, user might not have any hooks!
        log_error "Hook - $hook not present!"
        exit 1
    fi

}

__list_hooks() {
    local status="${1:-all}"
    local hooks_dir="$BOOT_HOOKS_DIR"
    if __hooks_dir_present; then
        case "$status" in
        enabled | e | active)
            find "$hooks_dir" -maxdepth 1 -type f -executable -exec echo {} \;
            ;;
        disabled | d | inactive)
            find "$hooks_dir" -maxdepth 1 -type f -not -executable -exec echo {} \;
            ;;
        all | a)
            find "$hooks_dir" -maxdepth 1 -type f -exec echo {} \;
            ;;
        *)
            log_error "Invalid state. State can be enabled | disabled | all"
            exit 1
            ;;
        esac
    else
        log_warn "Missing hooks directory - $BOOT_HOOKS_DIR"
    fi

}

__remove_hook() {
    local hook="$1"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        exit 1
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    https://* | http://* | file://* | ftp://*)
        log_error "Remove only supports locally installed hooks."
        exit 1
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    if [ -e "${hook}" ] && [ -f "$hook" ]; then
        log_info "Removing hook - $hook"
        if rm -f "${hook}"; then
            log_success "Removed hook - $hook"
        else
            log_error "Failed to remove hook - $hook"
            exit 1
        fi
    else
        log_error "hook not present - $hook"
        exit 1
    fi
}

__disable_hook() {
    local hook="$1"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        exit 1
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    https://* | http://* | file://* | ftp://*)
        log_error "Disable only supports locally installed hooks."
        exit 1
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    if [ -e "${hook}" ] && [ -f "$hook" ]; then
        if [ ! -x "$hook" ]; then
            log_info "hook is already disabled - $hook"
            exit 0
        else
            if chmod 600 "${hook}"; then
                log_success "Disabled hook - $hook"
            else
                log_error "Failed to disable hook - $hook"
                exit 1
            fi
        fi
    else
        log_error "hook not present - $hook"
        exit 1
    fi
}

__enable_hook() {
    local hook="$1"

    if [ -z "$hook" ]; then
        log_error "No hook specified!"
        exit 1
    fi

    case "$hook" in
    ${BOOT_HOOKS_DIR}*)
        :
        ;;
    https://* | http://* | file://* | ftp://*)
        log_error "Enable only supports locally installed hooks."
        exit 1
        ;;
    *)
        log_debug "Prepending path - $BOOT_HOOKS_DIR to hook path"
        hook="$BOOT_HOOKS_DIR/$hook"
        ;;
    esac

    if [ -e "${hook}" ] && [ -f "$hook" ]; then
        if [ -x "$hook" ]; then
            log_success "hook is already enabled - $hook"
            exit 0
        else
            if chmod 700 "${hook}"; then
                log_success "Enabled hook - $hook"
            else
                log_error "Failed to enable hook - $hook"
                exit 1
            fi
        fi
    else
        log_error "hook not present - $hook"
        exit 1
    fi
}

__download_hook() {
    local hook_type="${1:-none}"
    local hook_url="${2}"
    local hooks_dl_dir

    case "$hook_type" in
    boot)
        hooks_dl_dir="/tmp/703004ad-3b6c-4baa-84c5-868dd09acd06.download.boot-hooks"
        ;;
    container)
        hooks_dl_dir="/tmp/703004ad-3b6c-4baa-84c5-868dd09acd06.download.container-hooks"
        ;;
    *)
        log_error "Invalid Hook type - ${hook_type}"
        exit 2
        ;;
    esac

    case "$hook_url" in
    https://* | http://*)
        :
        ;;
    *)
        log_error "Invalid hook url - $hook_url"
        return 1
        ;;
    esac

    local hook_basename
    hook_basename="$(basename "$hook")"

    local hook_download_file="$hooks_dl_dir/$hook_basename"

    if __has_command wget; then
        log_info "Fetching via wget - $hook"
        if [ -e "$hooks_dl_dir" ] && [ ! -d "$hooks_dl_dir" ]; then
            log_error "Hook download path exists and is not a directory - $hook_tmp_dl_dir"
            return 1
        elif [ ! -e "$hooks_dl_dir" ]; then
            if ! mkdir "$hooks_dl_dir"; then
                log_error "Failed to create Hook download path - $hook_tmp_dl_dir"
                return 1
            fi
        fi

        if wget -O "$hook_download_file" "$hook_url"; then
            log_success "Downloaded - $hook_url to $hook_download_file"
            return 0
        else
            log_error "Failed to download - $hook_download_file"
            return 1
        fi

    else
        log_error "wget not available!"
        return 1
    fi

    return 1
}

__install_hook() {
    local hook="${1}"
    local install_name="${2}"
    local hooks_dir="$BOOT_HOOKS_DIR"
    local hook_tmp_dl_dir="/tmp/703004ad-3b6c-4baa-84c5-868dd09acd06.download.boot-hooks"

    if [ -z "${hook}" ]; then
        log_error "hook not specified!"
        display_usage
        exit 1
    fi

    if ! __hooks_dir_present; then
        if mkdir -p "$hooks_dir"; then
            log_success "Created hooks dir - $hooks_dir"
            if chmod 755 "$hooks_dir"; then
                :
            else
                log_error "Failed to set permission for $hooks_dir"
                exit 1
            fi
        else
            log_error "Failed to create hooks dir - $hooks_dir"
            exit 1
        fi
    fi

    case "$hook" in
    https://* | http://*)
        log_info "Hook appears to be a URL - $hook"
        if __download_hook "$hook_type" "$hook"; then
            log_info "Successfully downloded - $hook"
            log_info "Pivoting to local hook file - ${hook_tmp_dl_dir}/$(basename "$hook")"
            hook="${hook_tmp_dl_dir}/$(basename "$hook")"
        else
            log_error "Downloading hook failed - $hook"
            exit 1
        fi
        ;;
    file://* | ftp://*)
        log_error "Only http:// or https:// and local files are supported."
        exit 1
        ;;
    *)
        log_info "Hook file is local"
        ;;
    esac

    # check if install_name is not empty
    if [ -z "$install_name" ]; then
        install_name="$(basename "$hook")"
        log_warn "Inferring installed hook name($install_name) from source, This may not be what you desire!"
    fi

    # check if hook is already present in hooks_dir
    case $hook in
    $hooks_dir*)
        log_error "Hook file is already present in $hooks_dir"
        log_error "Did you mean to run - hookctl enable $hook ?"
        exit 1
        ;;
    esac

    local hook_installed_path
    hook_installed_path="$hooks_dir"/"$install_name"

    if [ -e "$hook_installed_path" ]; then
        if [ -f "$hook_installed_path" ]; then
            log_info "Removing existing hook file - $hook_installed_path"
            if rm -f "$hook_installed_path"; then
                log_success "Removed existing hook file - $hook_installed_path"
            else
                log_error "Failed to remove existing hook file - $hook_installed_path"
                exit 1
            fi
        else
            log_error "Existing hook is not a file - $hook_installed_path"
            exit 1
        fi
    fi

    log_info "Installing hook to - $hook_installed_path"
    if cp "$hook" "$hook_installed_path"; then
        log_success "Succesfully installed - $hook_installed_path"
        __enable_hook "$hook_installed_path"
    else
        log_error "Failed to install hook - $hook_installed_path"
        exit 1
    fi

}

main() {
    if [ $# -eq 0 ]; then
        display_usage
        exit 0
    fi

    while [ "${1}" != "" ]; do
        case ${1} in
        -h | --help | help)
            display_usage
            exit 0
            ;;
        ls | list)
            hookctl_enforce_ubios
            shift
            __list_hooks "$1"
            exit 0
            ;;
        rm | remove | delete)
            shift
            hookctl_enforce_ubios
            __remove_hook "${1}"
            exit 0
            ;;
        install | i)
            hookctl_enforce_ubios
            shift
            __install_hook "${1}" "${2}"
            exit 0
            ;;
        disable | d)
            hookctl_enforce_ubios
            shift
            __disable_hook "${1}"
            exit 0
            ;;
        invoke-all)
            hookctl_enforce_ubios
            shift
            __invoke_hook_all "$1"
            exit $?
            ;;
        invoke-start | run-start)
            hookctl_enforce_ubios
            shift
            __invoke_hook_single "start" "$1"
            exit 0
            ;;
        invoke-stop | run-stop)
            hookctl_enforce_ubios
            shift
            __invoke_hook_single "stop" "$1"
            exit 0
            ;;
        enable | e)
            hookctl_enforce_ubios
            shift
            __enable_hook "${1}"
            exit 0
            ;;
        *)
            log_error "Invalid argument(s). See usage below."
            display_usage
            exit 1
            ;;
        esac
        shift
    done
}

main "$@"
